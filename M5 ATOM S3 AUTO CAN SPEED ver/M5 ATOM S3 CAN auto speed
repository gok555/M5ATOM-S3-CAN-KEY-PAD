import M5
from M5 import *
import time
from unit import CANUnit, KMeterUnit
from hardware import I2C, Pin
import bluetooth
from micropython import const
from esp32 import NVS
# ==========================================
# ATOM S3 + ATOM CAN Base (Full BLE Ver)
# Based on Version 1.0 (Official Release)
# ==========================================
# --- Configuration for ATOM CAN Base ---
TX_PIN = 6
RX_PIN = 5
# ---------------------------------------
# --- CAN ID 変更方法 ---
# 送信CAN IDを別のアドレスに変更したい場合は、以下の `can_tx_id` の値を変更してください。
# 表記は16進数(0x...)です。
# 例: 0x100 -> 0x200
can_tx_id = 0x100
# K-Meter ID (Default 0x200)
k_meter_id = 0x200
# --- NVS Persistence (Ver 1.2) ---
try:
    nvs = NVS("can_app")
    try:
        saved_id = nvs.get_i32("my_id")
        can_tx_id = saved_id
        print(f"NVS Loaded ID: 0x{can_tx_id:X}")
    except OSError:
        print("NVS: No saved ID, using default")
        
    try:
        saved_kid = nvs.get_i32("k_meter_id")
        k_meter_id = saved_kid
        print(f"NVS Loaded KID: 0x{k_meter_id:X}")
    except OSError:
        print("NVS: No saved KID, using default")
        
except Exception as e:
    print("NVS Init Err:", e)
    nvs = None
DEVICE_NAME = "M5AtomS3_CAN_Base"
FIFO = 0
can_state = bytearray(8)
can_error = False
UART_UUID = bluetooth.UUID("6e400001-b5a3-f393-e0a9-e50e24dcca9e")
UART_TX   = bluetooth.UUID("6e400003-b5a3-f393-e0a9-e50e24dcca9e")
UART_RX   = bluetooth.UUID("6e400002-b5a3-f393-e0a9-e50e24dcca9e")
_IRQ_CENTRAL_CONNECT    = const(1)
_IRQ_CENTRAL_DISCONNECT = const(2)
_IRQ_GATTS_WRITE        = const(3)
class BLEUART:
    def __init__(self, ble):
        self._ble = ble
        self._ble.active(True)
        self._ble.irq(self._irq)
        ((self._tx, self._rx),) = self._ble.gatts_register_services([
            (UART_UUID, (
                (UART_TX, bluetooth.FLAG_NOTIFY),
                (UART_RX, bluetooth.FLAG_WRITE),
            )),
        ])
        self._connections = set()
        self._rx_cb = None
        self._adv_payload = self._get_adv_payload(DEVICE_NAME)
        self._advertise()
    def _get_adv_payload(self, name):
        name_bytes = name.encode()
        return b'\x02\x01\x06' + bytes([len(name_bytes)+1, 0x09]) + name_bytes
    def _advertise(self):
        try:
            self._ble.gap_advertise(100_000, self._adv_payload)
            print("BLE advertising...")
        except:
            pass
    def _irq(self, event, data):
        if event == _IRQ_CENTRAL_CONNECT:
            conn_handle, _, _ = data
            self._connections.add(conn_handle)
            print("BLE connected. Handle:", conn_handle)
            time.sleep(0.5)
            self.send_state_sync()
            # New: Send Config (ID Sync)
            time.sleep(0.1)
            self.send_config()
        elif event == _IRQ_CENTRAL_DISCONNECT:
            conn_handle, _, _ = data
            if conn_handle in self._connections:
                self._connections.remove(conn_handle)
            print("BLE disconnected")
            self._advertise()
        elif event == _IRQ_GATTS_WRITE:
            if self._rx_cb:
                self._rx_cb(self._ble.gatts_read(self._rx))
    def send(self, data):
        for conn_handle in self._connections:
            try:
                # Debug output
                # print("BLE Sending to:", conn_handle, data)
                self._ble.gatts_notify(conn_handle, self._tx, data)
                # print("BLE TX OK")
            except Exception as e:
                print("BLE TX ERR:", e)
    def send_state_sync(self):
        msg = "STATE=" + ",".join(str(b) for b in can_state)
        # print("Preparing Sync Msg:", msg)
        self.send(msg.encode())
    def send_status(self, is_err):
        st = "CAN_ERR" if is_err else "CAN_OK"
        msg = f"STATUS={st}"
        # print("Heartbeat:", msg)
        # print("Heartbeat:", msg)
        self.send(msg.encode())
    def send_config(self):
        # Sync IDs
        msg = f"ID={hex(can_tx_id)}"
        self.send(msg.encode())
        time.sleep(0.05)
        msg = f"KID={hex(k_meter_id)}"
        self.send(msg.encode())
    def on_rx(self, cb):
        self._rx_cb = cb
# --- Auto Baud Rate Detection ---
def detect_baudrate():
    M5.Display.clear()
    M5.Display.setCursor(0, 0)
    M5.Display.setTextSize(2)
    M5.Display.setTextColor(0xFFFF)
    M5.Display.print("Detecting\nBaudrate...")
    print("Auto-Detecting Baudrate...")
    
    # Candidates list
    candidates = [1000000, 500000]
    
    # Retry logic: Try more times, slightly longer wait
    for attempt in range(5): 
        print(f"--- Attempt {attempt+1} ---")
        for rate in candidates:
            print(f"Scanning {rate}...")
            can = None
            try:
                # 1. Close any existing (just in case)
                # But 'can' is local. Maybe previous loop left something?
                # We trust deinit() at end of loop.
                
                # 2. Init - MODIFIED FOR BASE PINS
                can = CANUnit(id=0, port=(TX_PIN, RX_PIN), mode=CANUnit.NORMAL, baudrate=rate)
                
                # 3. Listen
                # 500kbps sends slower, maybe 500ms is on edge if traffic is sparse?
                # Increase to 1000ms per check to be safe.
                start = time.ticks_ms()
                detected = False
                
                while time.ticks_diff(time.ticks_ms(), start) < 1000:
                    try:
                        if can.any(0) > 0:
                            # Verify it's not a garbage frame?
                            # Just presence is enough for now.
                            detected = True
                            print(f"  -> Msg Found! Count={can.any(0)}")
                            break
                    except:
                        pass
                    time.sleep_ms(50)
                
                # 4. Cleanup current test instance
                if hasattr(can, 'deinit'):
                    can.deinit()
                
                # 5. Result
                if detected:
                    print(f"DETECTED: {rate}")
                    return rate
                    
            except Exception as e:
                print(f"Err {rate}: {e}")
                # Ensure cleanup on error
                if can: 
                    try: 
                        if hasattr(can, 'deinit'): can.deinit() 
                    except: pass
            
            # Small pause between rates to let bus settle?
            time.sleep_ms(200)
            
    print("Detection Failed -> Defaulting to 1000k")
    return 1000000 # Default default
def on_ble_rx(data):
    try:
        cmd = data.decode().strip()
        print("BLE RX:", cmd)
        updated = False
        if '=' in cmd: 
            parts = cmd.split('=')
            # Check for ID command
            if parts[0] == "ID":
                try:
                    new_id = int(parts[1], 16) # Parse as Hex
                    global can_tx_id
                    can_tx_id = new_id
                    print("New CAN ID:", hex(can_tx_id))
                    
                    # --- NVS Save (Ver 1.2) ---
                    if nvs:
                        try:
                            nvs.set_i32("my_id", new_id)
                            nvs.commit()
                            print("NVS Saved ID")
                        except Exception as e:
                            print("NVS Save Err:", e)
                    # --------------------------
                    # Optional: Send sync to confirm?
                except:
                    print("Invalid ID Fmt")
            # --- K-Meter ID Command (Ver 1.3) ---
            elif parts[0] == "KID":
                try:
                    new_kid = int(parts[1], 16) # Parse as Hex
                    global k_meter_id
                    k_meter_id = new_kid
                    print("New K-Meter ID:", hex(k_meter_id))
                    
                    if nvs:
                        try:
                            nvs.set_i32("k_meter_id", new_kid)
                            nvs.commit()
                            print("NVS Saved KID")
                        except Exception as e:
                            print("NVS Save Err:", e)
                except:
                    print("Invalid KID Fmt")
            # ------------------------------------
            elif len(parts) == 2 and parts[0].isdigit() and parts[1].isdigit():
                idx = int(parts[0]) - 1
                val = int(parts[1])
                if 0 <= idx < 8:
                    # Version 2.7: Allow arbitrary byte value
                    if can_state[idx] != val:
                        can_state[idx] = val & 0xFF # Ensure byte range
                        updated = True
        elif cmd.isdigit(): 
            idx = int(cmd) - 1
            if 0 <= idx < 8:
                can_state[idx] ^= 1
                can_state[idx] ^= 1
                updated = True
        # New Command: GETCONFIG
        elif cmd == "GETCONFIG":
            uart.send_config()
        if updated:
            print("CAN TX:", list(can_state))
            can.send(id=can_tx_id, data=can_state)
            uart.send_state_sync()
    except Exception as e:
        print("RX ERR:", e)
# ---------------------------------------------
# Main Setup
# ---------------------------------------------
M5.begin()
print("BOOT ATOM S3 CAN Base - BLE Ver 1.1")
# Run Detection
detected_rate = detect_baudrate()
print(f"Using Baudrate: {detected_rate}")
# Init Main CAN
try:
    # MODIFIED FOR BASE PINS
    can = CANUnit(id=0, port=(TX_PIN, RX_PIN), mode=CANUnit.NORMAL, baudrate=detected_rate)
    print("CAN OK")
except Exception as e:
    print("CAN Init Err:", e)
# Init K-Meter
kmeter = None
try:
    # ATOM S3 Grove: SCL=G1, SDA=G2 (Sample said scl=Pin(1), sda=Pin(2))
    i2c0 = I2C(0, scl=Pin(1), sda=Pin(2), freq=100000)
    kmeter = KMeterUnit(i2c0, 0x66)
    print("KMeter Init OK")
except Exception as e:
    print("KMeter Init Err:", e)
ble = bluetooth.BLE()
uart = BLEUART(ble)
uart.on_rx(on_ble_rx)
M5.Display.clear()
M5.Display.setCursor(0, 0)
M5.Display.setTextSize(2)
M5.Display.setTextColor(0xFFFFFF)
M5.Display.print("READY\n(Base)\n")
# Show detected baudrate at bottom
M5.Display.setCursor(0, 64) # Move to middle/bottom
M5.Display.setTextSize(3) # Larger font
if detected_rate >= 1000000:
    M5.Display.setTextColor(0x07E0) # GREEN for 1M
    M5.Display.print("1M")
else:
    M5.Display.setTextColor(0xFFE0) # YELLOW for 500k
    M5.Display.print("500k")
print("READY")
last_display_update = 0
DISPLAY_INTERVAL = 500
def update_lcd():
    # Use fillScreen instead of clear to avoid issues
    M5.Display.clear()
    M5.Display.setCursor(0, 0)
    M5.Display.setTextSize(2)
    
    # CAN Status -> GREEN (0x07E0)
    if can_error:
        M5.Display.setTextColor(0xF800, 0) # RED
        M5.Display.print("CAN: ERR\n")
    else:
        M5.Display.setTextColor(0x07E0, 0) # GREEN
        M5.Display.print("CAN: OK \n")
        
    # BLE Status -> YELLOW (0xFFE0) 
    if len(uart._connections) > 0:
        M5.Display.setTextColor(0xFFE0, 0) # YELLOW
        M5.Display.print("BLE: ON \n")
    else:
        M5.Display.setTextColor(0x7BEF, 0) # GREY
        M5.Display.print("BLE: -- \n")
        
    
    
    # ID -> WHITE (0xFFFF)
    # Line 3 (Y=38) - Move down to avoid top overlap
    M5.Display.setCursor(0, 38)
    M5.Display.setTextColor(0xFFFF, 0) # WHITE
    M5.Display.print(f"TX ID:{can_tx_id:X}\n")
    
    
    # Speed -> Bottom Left (Smaller) - Move up from Y=95 to Y=88 to fix cutoff
    M5.Display.setCursor(0, 88)
    M5.Display.setTextSize(2)
    if detected_rate >= 1000000:
        M5.Display.setTextColor(0x07E0) # GREEN
        M5.Display.print("1M")
    else:
        M5.Display.setTextColor(0xFFE0) # YELLOW
        M5.Display.print("500k")
last_can_send_time = 0
CAN_SEND_INTERVAL = 200  # 5Hz
last_ble_sync_time = 0
BLE_SYNC_INTERVAL = 1000 # 1Hz (Heartbeat for UI)
last_temp_send_time = 0
TEMP_SEND_INTERVAL = 200 # 5Hz (Changed from 50ms)
while True:
    M5.update()
    # Cyclic CAN Transmission (Heartbeat)
    now = time.ticks_ms()
    
    # --- Button A (Screen Press) -> Send ID 0x200 (User Feature) ---
    if BtnA.wasPressed():
        try:
            # Prepare test data for ID 200
            # Just some recognizable pattern + counter
            # tx_cnt is local in loop? No, global needed if we want it to increment.
            # But wait, tx_cnt was used in basic version, not defined in BLE version loop scope yet.
            # Let's define a local static or use a random value? 
            # Or just use the global 'can_state' but send it on ID 200?
            # User request: "Send CAN data with ID 200".
            # Let's create a specific payload.
            test_data = bytearray([0xA1, 0xB2, 0xC3, 0xD4, 0xE5, 0xF6, 0x07, 0x08])
            
            can.send(id=0x200, data=test_data)
            print("[BTN] Sent ID 0x200")
            
            # Visual Feedback
            M5.Display.setTextColor(0x00FFFF) # Cyan
            M5.Display.setCursor(64, 100) # Right side bottom?
            M5.Display.print("TX:200")
            
        except Exception as e:
            print("[BTN TX ERR]", e)
# --- Feature: K-Meter (Temp) ---
    if time.ticks_diff(now, last_temp_send_time) > TEMP_SEND_INTERVAL:
        try:
            # Read Temp
            if kmeter:
                temp_val = kmeter.get_temperature() # Returns float/int? Usually float (e.g. 25.4)
                # print("Temp:", temp_val)
                
                # Format Data: 4 Bytes Float (or simulated fixed point)
                # Let's use simple fixed point for robustness if struct isn't trusted, but struct is best.
                # Data: [T_High, T_Low, 0, 0, ...] - 2 Bytes for Integer (Signed or Unsigned?)
                # User asked for "1000 degree" -> 2 bytes. Maybe Big Endian?
                # Using 16-bit Signed Integer (Big Endian): Bytes 2,3 (Wait, previous was Sign, Int, Dec)
                # Let's change payload structure to match user request: "Extend range to 1000"
                # Payload: [ValidFlag, Sign, T_High, T_Low, 0, 0, 0, 0]
                # High Byte = (t_int >> 8) & 0xFF
                # Low Byte = t_int & 0xFF
                
                # Make sure temp_val is valid number
                if isinstance(temp_val, (int, float)):
                    t_int = int(temp_val)
                    # t_dec = int(abs(temp_val * 100) % 100) # Dropped decimal support for space? No, just user said "integer part". But payload?
                    # User instructions imply: "1000C support". 
                    # Let's use 2 bytes for Integer part.
                    # Sign is separate? Or 2-byte signed int?
                    # Standard: 2-byte Signed Int (Big Endian) covers -32768 to 32767.
                    
                    sign = 1 if temp_val >= 0 else 0 
                    abs_val = abs(t_int)
                    
                    # Payload: [Valid, Sign, High, Low, Dec?, 0, 0, 0]
                    # Let's keep Sign explicit at Byte 1 for backward compat with my own logic if possible, 
                    # but range > 255 needs 2 bytes.
                    # Byte 2 = High, Byte 3 = Low
                    
                    sensor_data = bytearray([0x01, sign, (abs_val >> 8) & 0xFF, abs_val & 0xFF, 0,0,0,0])
                    
                    can.send(id=k_meter_id, data=sensor_data)
                    
                    # Send Temp via BLE (Integer only) - String handles 1000 fine
                    uart.send(f"TEMP={t_int}".encode())
                    
                    # Update LCD with Temp (Top Right?)
                    # M5.Display.setCursor(80, 0)
                    # M5.Display.print(f"{temp_val:.1f}C")
                    
        except Exception as e:
            # print("Temp Err:", e)
            pass
        last_temp_send_time = now
    if time.ticks_diff(now, last_can_send_time) > CAN_SEND_INTERVAL:
        try:
            can.send(id=can_tx_id, data=can_state)
            can_error = False
        except Exception as e:
            print("CAN Send Err:", e)
            can_error = True
        last_can_send_time = now
    # Cyclic BLE Sync (UI Refresh Heartbeat)
    if time.ticks_diff(now, last_ble_sync_time) > BLE_SYNC_INTERVAL:
        uart.send_state_sync() # Button States
        uart.send_status(can_error) # Heartbeat & CAN Status
        last_ble_sync_time = now
    # LCD Update
    if time.ticks_diff(now, last_display_update) > DISPLAY_INTERVAL:
        try:
            update_lcd()
        except Exception as e:
            print("LCD Err:", e)
        last_display_update = now
    # --- CAN RX & Display ---
    if can and can.any(FIFO):
        try:
            msg = can.recv(FIFO)
            if msg:
                can_id, is_ext, rtr, dlc, rx_data = msg
                
                # Monitor specific ID (User Req: Show RX ID & Temp)
                # Display on LCD (Bottom Area)
                # Clear previous line not needed if we overwrite, but good practice
                # Only update if rate limited or on change? User said "Low refresh rate".
                # Let's update here but maybe skip if too fast.
                
                # Check ALL IDs or just KMeter? User said "RX ID".
                # Let's show the ID of the received message as RX ID.
                # And if it is KMeter ID, try to parse temp?
                # User said: "RX ID" -> Temp (Integer)
                
                # Use a separate area or overwrite the bottom?
                # Move higher to avoid cutoff. Speed is now smaller at bottom left.
                # Let's put RX ID and Temp in the middle-bottom area.
                # Y=60 was overlapping Y=32? No, 32+16=48. 60 is fine.
                # But user said "Overlapping". Maybe Y=32 is too low?
                # I adjusted TX ID to Y=38.
                # Let's move RX ID to Y=63.
                M5.Display.fillRect(0, 63, 128, 45, 0x000000)
                M5.Display.setCursor(0, 63)
                M5.Display.setTextSize(2) 
                M5.Display.setTextColor(0x00FFFF) # Cyan for RX
                
                # RX ID - Removed 0x as per user request to save space
                M5.Display.print(f"RX ID:{can_id:X}\n")
                
                # Parse Temp (Assuming KMeter format or similar)
                # KMeter sends: [Valid, Sign, High, Low, ...]
                # If dlc >= 4:
                temp_str = "---"
                if dlc >= 4:
                     # New 2-byte parsing
                     # Byte 2 = High, Byte 3 = Low
                     t_high = rx_data[2]
                     t_low = rx_data[3]
                     val = (t_high << 8) | t_low
                     
                     t_sign = rx_data[1]
                     if t_sign == 0: # Negative?
                         # Logic in send: sign = 1 if temp_val >= 0 else 0
                         # So 1 is positive, 0 is negative.
                         val = -val
                         
                     temp_str = f"{val}C"
                
                # Temp -> Red
                M5.Display.setTextColor(0xF800) # RED
                M5.Display.print(f"Temp:{temp_str}")
                    
                            
        except Exception as e:
            print("CAN RX Err:", e)
            
    time.sleep(0.01)
